#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/utils.fc";


global int   storage::init?;

global slice storage::admin_address;           ;; Launchpad (royalty) address  (MsgAddress)
global slice storage::owner_address;           ;; owner address (MsgAddress)
global cell  storage::content;                 ;; collection content (Cell)
global cell  storage::sbt_item_code;           ;; NFT code (Cell)

global cell  storage::purchase_conditions;     ;; Cell with purchases conditions for different WL lvls (Cell)
global cell  storage::commission_factors;      ;; Hashmap. Key = minimum collected ton (uint128), Value = commission factor (uint32)

global int   storage::default_discount;        ;; discount factor for default users (uint32)
global int   storage::default_cashback;        ;; cashback factor for default users (uint32)

global int   storage::min_ref_purchase;        ;; minimum purchase volume to get ref code (Coins)
global cell  storage::refs_dict;               ;; HashmapE. Key = ref_address (uint256), Value = slice(cashback_factor(uint32), discount_factor_factor(uin32));
global cell  storage::ref_wallet_code;         ;; Code of the ref_wallet smart contract (Cell)

global int   storage::sale_start_time;         ;; time of the start of sale  (uint32)
global int   storage::sale_end_time;           ;; time of the end of sale  (uint32)

global int   storage::min_ton_collected;       ;; minimum amount of collected TON for successful finish (Coins)
global int   storage::allocated_jettons;       ;; total allocated for sale and liquidity jettons (Coins)
global int   storage::liquidity_part_ton;      ;; Percent of collected TON allocated for liquidity, all the remaining TON will go to founder (uint32)
global int   storage::liquidity_part_jetton;   ;; Percent of jettons allocated for liquidity, remaining will be sold (uint32)

global int   storage::ton_collected;           ;; amount of collected TON (Coins)
global int   storage::jettons_sold;            ;; amount of sold jettons (Coins)

global int   storage::first_unlock_time;       ;; time of first unlock in seconds (uint32)
global int   storage::first_unlock_size;       ;; percent of tokens unlocked at first (uint32)
global int   storage::cycle_length;            ;; time between unlocks in seconds (uint32)
global int   storage::cycles_number;           ;; number of unlocks excluding initial (uint16)

global slice storage::jetton_root_address;     ;; jetton root address (MsgAddress)
global slice storage::native_vault_address;    ;; native vault address (MsgAddress)
global slice storage::jetton_vault_address;    ;; jetton vault address (MsgAddress)

global slice storage::jetton_wallet_address;   ;; jetton wallet address of this smc (MsgAddress)
global int   storage::jettons_added?;          ;; Were jettons added to smart contract? (uint1)
global int   storage::sale_finished?;          ;; Were collected TON sent to recipients? (uint1)


global int jettons_for_sale;


() load_data() impure inline {
    slice ds = get_data().begin_parse(); ;; data: 1 + 32 + 32 + 128 + 128 + 32 + 32 + 128 + 128 + 32 + 32 + 32 + 16 + 267 + 1 + 1 = 1022
                                         ;; refs: collection_info + internal_ds + ref_conditions = 3
    
    storage::init?                 = ds~load_int(1);

    storage::sale_start_time       = ds~load_uint(32);
    storage::sale_end_time         = ds~load_uint(32);

    storage::min_ton_collected     = ds~load_coins();
    storage::allocated_jettons     = ds~load_coins();
    storage::liquidity_part_ton    = ds~load_uint(32);
    storage::liquidity_part_jetton = ds~load_uint(32);

    storage::ton_collected         = ds~load_coins();
    storage::jettons_sold          = ds~load_coins();

    storage::first_unlock_time     = ds~load_uint(32);
    storage::first_unlock_size     = ds~load_uint(32);
    storage::cycle_length          = ds~load_uint(32);
    storage::cycles_number         = ds~load_uint(16);

    storage::jetton_wallet_address = ds~load_msg_addr();
    storage::jettons_added?        = ds~load_int(1);
    storage::sale_finished?        = ds~load_int(1);

    slice collection_info          = ds~load_ref().begin_parse(); ;; data: 267 + 267 = 534; refs: content + sbt_item_code = 2
    storage::admin_address         = collection_info~load_msg_addr();
    storage::owner_address         = collection_info~load_msg_addr();
    storage::content               = collection_info~load_ref();
    storage::sbt_item_code         = collection_info~load_ref();

    slice internal_ds              = ds~load_ref().begin_parse(); ;; data: 267 + 267 + 267 = 801; refs: purchaise_conditions + commission_factors = 2
    storage::jetton_root_address   = internal_ds~load_msg_addr();
    storage::native_vault_address  = internal_ds~load_msg_addr();
    storage::jetton_vault_address  = internal_ds~load_msg_addr();
    storage::purchase_conditions   = internal_ds~load_ref();
    storage::commission_factors    = internal_ds~load_ref();
    
    slice ref_conditions           = ds~load_ref().begin_parse(); ;; data: 128 + 32 + 32 + 1 = 193; refs: refs_dict + ref_wallet_code = 2
    storage::min_ref_purchase      = ref_conditions~load_coins();
    storage::default_discount      = ref_conditions~load_uint(32);
    storage::default_cashback      = ref_conditions~load_uint(32);
    storage::refs_dict             = ref_conditions~load_dict();
    storage::ref_wallet_code       = ref_conditions~load_ref(); 

    jettons_for_sale = storage::jettons_added? ? muldiv(storage::allocated_jettons, (percent_devider - storage::liquidity_part_jetton), percent_devider) : 0;
}


() save_data() impure inline {
    set_data(
        begin_cell()
            .store_int(storage::init?, 1)

            .store_uint(storage::sale_start_time, 32)
            .store_uint(storage::sale_end_time, 32)
            
            .store_coins(storage::min_ton_collected)
            .store_coins(storage::allocated_jettons)
            .store_uint(storage::liquidity_part_ton, 32)
            .store_uint(storage::liquidity_part_jetton, 32)

            .store_coins(storage::ton_collected)
            .store_coins(storage::jettons_sold)

            .store_uint(storage::first_unlock_time, 32)
            .store_uint(storage::first_unlock_size, 32)
            .store_uint(storage::cycle_length, 32)
            .store_uint(storage::cycles_number, 16)
            
            .store_slice(storage::jetton_wallet_address)
            .store_int(storage::jettons_added?, 1)
            .store_int(storage::sale_finished?, 1)

            .store_ref( ;; collection_info
                begin_cell()
                    .store_slice(storage::admin_address)
                    .store_slice(storage::owner_address)
                    .store_ref(storage::content)
                    .store_ref(storage::sbt_item_code)
                .end_cell()
            ) ;; \collection_info
            .store_ref( ;; internal_ds
                begin_cell()
                .store_slice(storage::jetton_root_address)
                .store_slice(storage::native_vault_address)
                .store_slice(storage::jetton_vault_address)
                .store_ref(storage::purchase_conditions)
                .store_ref(storage::commission_factors)
                .end_cell()
            ) ;; \internal_ds
            .store_ref( ;; ref_conditions
                begin_cell()
                    .store_coins(storage::min_ref_purchase)
                    .store_uint(storage::default_discount, 32)
                    .store_uint(storage::default_cashback, 32)
                    .store_dict(storage::refs_dict)
                    .store_ref(storage::ref_wallet_code)
                .end_cell()
            ) ;; \ref_conditions
        .end_cell()
    );
}

builder store_pool_params_native_jetton(builder b, int jetton_root_workchain, int jetton_root_address_hash) inline {
    return b.store_uint(1, 9).store_uint(jetton_root_workchain, 8).store_uint(jetton_root_address_hash, 256);
}

() provide_liquidity(int query_id, int jetton_amount, int ton_amount) impure inline {
    ton_amount -= ONE_TON;

    (int jetton_root_workchain, int jetton_root_address_hash) = parse_std_addr(storage::jetton_root_address);
    cell fulfill_payload = begin_cell().store_uint(op::liquidity_fulfill, 32).end_cell();
    cell reject_payload = begin_cell().store_uint(op::liquidity_reject, 32).end_cell();

    builder assets = begin_cell().store_coins(0).store_coins(ton_amount).store_coins(jetton_amount);

    cell native_provide_lp_message = begin_cell()
                                        .store_uint(op::deposit_liquidity_native, 32)
                                        .store_uint(query_id, 64)
                                        .store_coins(ton_amount)
                                        .store_pool_params_native_jetton(jetton_root_workchain, jetton_root_address_hash)
                                        .store_ref(assets.end_cell())
                                        .store_maybe_ref(fulfill_payload)
                                        .store_maybe_ref(reject_payload)
                                    .end_cell();

    cell jetton_provide_lp_message = begin_cell()
                                        .store_uint(op::deposit_liquidity_jetton, 32)
                                        .store_pool_params_native_jetton(jetton_root_workchain, jetton_root_address_hash)
                                        .store_builder(assets)
                                        .store_maybe_ref(fulfill_payload)
                                        .store_maybe_ref(reject_payload)
                                    .end_cell();

    send_cell_message(storage::native_vault_address, gas::provide_ton, native_provide_lp_message, mode::simple);
    send_jettons(query_id, jetton_amount, storage::jetton_vault_address, my_address(), storage::jetton_wallet_address, gas::provide_jetton + gas::send_jettons, 
                 mode::simple, gas::provide_jetton, jetton_provide_lp_message);
}


() sell_tokens(int query_id, int msg_value, slice buyer_address, int price_factor, int price_devider, 
                int min_purchase_ton, int max_purchase_ton, slice ref_address, int cashback_factor) impure inline {
    msg_value -= gas::purchase;
    int jettons_to_purchase = muldiv(msg_value, price_devider, price_factor);
    storage::jettons_sold += jettons_to_purchase;
    int ref_cashback = muldiv(msg_value, cashback_factor, percent_devider);
    storage::ton_collected += msg_value - ref_cashback;

    throw_unless(exc::less_than_min_purchase, msg_value >= min_purchase_ton);
    throw_unless(exc::more_than_max_purchase, msg_value <= max_purchase_ton);
    throw_unless(exc::not_enough_jettons, storage::jettons_sold < jettons_for_sale);

    (int worckchain, int buyer_address_int) = parse_std_addr(buyer_address);

    cell sbt_state_init = calculate_nft_item_state_init(buyer_address_int, storage::sbt_item_code, my_address());
    slice sbt_address = get_address_by_state_init(sbt_state_init);
    
    builder sbt_message = begin_cell()
                            .store_uint(op::update_sbt_data, 32)
                            .store_uint(query_id, 64)
                            .store_coins(jettons_to_purchase)
                            .store_coins(msg_value)
                            .store_coins(max_purchase_ton)
                            .store_uint(storage::first_unlock_time, 32)
                            .store_uint(storage::first_unlock_size, 32)
                            .store_uint(storage::cycle_length, 32)
                            .store_uint(storage::cycles_number, 16);
    if (cashback_factor) {
        sbt_message = sbt_message.store_maybe_ref(
            begin_cell().store_slice(ref_address).store_uint(cashback_factor, 32).end_cell()
        );
    }
    else {
        sbt_message = sbt_message.store_uint(0, 1);
    }
    send_deploy_message(sbt_address, gas::deploy_sbt, sbt_state_init, sbt_message.end_cell(), mode::simple); 

    save_data();
    return ();
}


() cancel_purchase(slice buyer_address, int ton_to_return, int purchased_jettons) impure inline {
    send_message_with_comment(buyer_address, ton_to_return, "Unsuccessful purchase", mode::simple);

    storage::jettons_sold -= purchased_jettons;
    storage::ton_collected -= ton_to_return;

    save_data();
    return ();
}


() approve_purchase(int query_id, slice buyer_address, int received_ton, slice ref_data) impure inline {
    ;; update "total cashback" for buyer's invitee
    ifnot(slice_empty?(ref_data)) {
        (slice ref_address, int cashback_factor) = (ref_data~load_msg_addr(), ref_data~load_uint(32));
        int cashback = muldiv(received_ton, cashback_factor, percent_devider);
        builder msg_body = begin_cell()
                            .store_uint(op::update_ref_wallet, 32)
                            .store_uint(query_id, 64)
                            .store_coins(cashback);
        send_builder_message(ref_address, gas::update_wallet, msg_body, mode::simple);
    }
    
    ;; deploy buyer's ref_wallet
    if (received_ton > storage::min_ref_purchase) {
        cell ref_wallet_state_init = calculate_ref_wallet_state_init(buyer_address, storage::ref_wallet_code, storage::sale_end_time);
        send_deploy_message(get_address_by_state_init(ref_wallet_state_init), gas::deploy_ref, ref_wallet_state_init, null(), mode::simple);
    }

    return ();
}


() finish_sale(slice sender_address, int query_id) {
    raw_reserve(0, 4);

    ;; Sale failed
    if (storage::ton_collected < storage::min_ton_collected) { 
        send_jettons(query_id, storage::allocated_jettons, storage::owner_address, sender_address, storage::jetton_wallet_address,
                     gas::send_jettons, mode::simple, 0, begin_cell().store_uint(0, 32).store_slice("Unfortunately, your tokensale was unsuccessful").end_cell());   
    }
    ;; Sale succeed
    else {
        int total_used_jettons = muldiv(storage::jettons_sold, percent_devider, (percent_devider - storage::liquidity_part_jetton));
        
        int jettons_to_burn = storage::allocated_jettons - total_used_jettons;
        burn_jettons(query_id, jettons_to_burn, storage::jetton_wallet_address, sender_address, gas::burn_jettons, mode::simple);

        int jettons_for_liquidity = muldiv(total_used_jettons, storage::liquidity_part_jetton, percent_devider);
        
        int ton_for_liquidity = muldiv(storage::ton_collected, storage::liquidity_part_ton, percent_devider);
        provide_liquidity(query_id, jettons_for_liquidity, ton_for_liquidity);

        (_, slice cfs, int success) = storage::commission_factors.udict_get_preveq?(128, storage::ton_collected);
        int ton_for_launchpad = muldiv(storage::ton_collected, cfs~load_uint(32), percent_devider);
        send_builder_message(storage::admin_address, ton_for_launchpad, begin_cell().store_uint(op::send_commissions, 32).store_uint(query_id, 64), mode::simple);

        int ton_for_founder = storage::ton_collected - ton_for_launchpad - ton_for_liquidity;
        send_message_with_comment(storage::owner_address, ton_for_founder, "JVault Launchpad payout for ICO creator", mode::simple);
    }

    send_builder_message(sender_address, 0, begin_cell().store_uint(op::excesses, 32).store_uint(query_id, 64), mode::carry_remaining_balance);
    storage::sale_finished? = true;
    save_data();
    return ();
}


(slice, int, int) get_referral_data(slice in_msg_body) inline {
    slice ref_address = null();
    int discount_factor = 0;
    int cashback_factor = 0;
    ifnot (in_msg_body.slice_refs_empty?()) {
        slice from_address = in_msg_body~load_ref().begin_parse();
        (int workchain, int from_address_int) = parse_std_addr(from_address);

        (slice refs_conditions, int success) = storage::refs_dict.udict_get?(256, from_address_int);
        if (success) {  ;; special conditions
            discount_factor = refs_conditions~load_uint(32);  
            cashback_factor = refs_conditions~load_uint(32);
        }
        else {  ;; default conditions
            discount_factor = storage::default_discount;
            cashback_factor = storage::default_cashback; 
        }
        ref_address = get_address_by_state_init(calculate_ref_wallet_state_init(from_address, storage::ref_wallet_code, storage::sale_end_time  ));
    }
    return (ref_address, discount_factor, cashback_factor);
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {
        in_msg_body~skip_bits(32);
        int op = in_msg_body~load_uint(32);
        if (op == op::update_ref_wallet) {  ;; Handle bounced messages from undeployed ref_wallets
            storage::ton_collected += in_msg_body~load_coins();
            save_data();
        }
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    (int workchain, int sender_address_int) = parse_std_addr(sender_address);
    throw_unless(exc::wrong_chain, workchain == 0);

    load_data();

    int op = in_msg_body.slice_empty?() ? 0 : in_msg_body~load_uint(32);
    int query_id = in_msg_body.slice_empty?() ? cur_lt() : in_msg_body~load_uint(64);

    ifnot (storage::init?) {
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::admin_address));

        builder msg_body = begin_cell()
                            .store_uint(op::provide_wallet_address, 32)
                            .store_uint(query_id, 64)
                            .store_slice(my_address())
                            .store_uint(0, 1);
        send_builder_message(storage::jetton_wallet_address, gas::provide_addr, msg_body, mode::simple);

        save_data();
        return ();
    }
    
    if ((op == op::ownership_proof) | (op == 0)) { 
        throw_unless(exc::sale_not_started, now() > storage::sale_start_time);
        throw_unless(exc::sale_finished, now() < storage::sale_end_time);

        slice purchase_conditions_parsed = storage::purchase_conditions.begin_parse();
        
        if (op == op::ownership_proof) {  ;; message from WL sbt
            int wl_sbt_index = in_msg_body~load_uint(256);
            slice owner_address = in_msg_body~load_msg_addr();

            in_msg_body = in_msg_body~load_ref().begin_parse();
            int wl_index = in_msg_body~load_uint(2);  ;; this sale supports up to 4 whitelist levels
            purchase_conditions_parsed = purchase_conditions_parsed.preload_ref_index(wl_index).begin_parse();
            
            cell wl_sbt_code = purchase_conditions_parsed~load_ref();
            slice wl_collection_address = purchase_conditions_parsed~load_msg_addr();
            slice expected_wl_sbt_address = get_address_by_state_init(calculate_nft_item_state_init(wl_sbt_index, wl_sbt_code, wl_collection_address));

            throw_unless(exc::incorrect_sender, equal_slices(expected_wl_sbt_address, sender_address));
            sender_address = owner_address;
        } 
        
        int price_factor     = purchase_conditions_parsed~load_uint(128);
        int price_devider    = purchase_conditions_parsed~load_uint(128);
        int min_purchase_ton = purchase_conditions_parsed~load_coins();
        int max_purchase_ton = purchase_conditions_parsed~load_coins();

        (slice ref_address, int discount_factor, int cashback_factor) = get_referral_data(in_msg_body);

        sell_tokens(query_id, msg_value, sender_address, price_factor * (percent_devider - discount_factor), price_devider * percent_devider, min_purchase_ton, max_purchase_ton, ref_address, cashback_factor);
        return ();
    }

    ;; End sale (provide liquidity and send TON to creator & launchpad)
    if (op == op::end_sale) {
        throw_unless(exc::out_of_gas, msg_value >= gas::end_sale);
        throw_unless(exc::sale_not_finished, now() > storage::sale_end_time);
        throw_if(exc::sale_finished, storage::sale_finished?);
        
        finish_sale(sender_address, query_id);
        return ();
    }

    ;; messages from SBT
    if ((op == op::claim) | (op == op::cancel_purchase) | (op == op::approve_purchase) | (op == op::request_refund)) {
        int sbt_index = in_msg_body~load_uint(256);
        slice expected_address = get_address_by_state_init(calculate_nft_item_state_init(sbt_index, storage::sbt_item_code, my_address()));
        throw_unless(exc::incorrect_sender, equal_slices(expected_address, sender_address));
        
        slice sbt_owner_address = begin_cell().store_uint(1024, 11).store_uint(sbt_index, 256).end_cell().begin_parse();
        int coins_amount = in_msg_body~load_coins();

        if (op == op::claim) {
            throw_unless(exc::sale_failed, storage::ton_collected < storage::min_ton_collected);
            throw_unless(exc::sale_not_finished, storage::sale_finished?);

            send_jettons(query_id, coins_amount, sbt_owner_address, sbt_owner_address, storage::jetton_wallet_address, 0, 
                            mode::carry_remaining_gas, 1, begin_cell().store_uint(0, 32).store_slice("Claim from JVault Launchpad").end_cell());
        }
        if (op == op::request_refund) {
            throw_unless(exc::sale_not_finished, now() > storage::sale_end_time);
            throw_unless(exc::sale_succeed, storage::ton_collected >= storage::min_ton_collected);
            send_message_with_comment(sbt_owner_address, coins_amount, "Tokensale was unsuccessful", mode::simple);
        }
        if (op == op::cancel_purchase) {
            int ton_to_return = in_msg_body~load_coins();
            cancel_purchase(sbt_owner_address, ton_to_return, coins_amount);
        }
        if (op == op::approve_purchase) {
            slice ref_data = in_msg_body~load_dict().begin_parse();
            approve_purchase(query_id, sbt_owner_address, coins_amount, ref_data);
        }

        return ();
    }

    ;; message from ref_wallet
    if (op == op::claim_ref) {
        throw_if(exc::sale_failed, storage::ton_collected < storage::min_ton_collected);

        slice ref_owner_address = in_msg_body~load_msg_addr();
        slice expected_address = get_address_by_state_init(calculate_ref_wallet_state_init(ref_owner_address, storage::ref_wallet_code, storage::sale_end_time));
        throw_unless(exc::incorrect_sender, equal_slices(expected_address, sender_address));

        int ref_reward = in_msg_body~load_coins();
        send_message_with_comment(ref_owner_address, ref_reward, "Cashback from referrals on JVault launchpad", mode::simple);
        return ();
    }

    ;; set jetton wallet address (used only once)
    if (op == op::take_wallet_address) {
        throw_if(exc::already_inited, storage::init?);  
        throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::jetton_wallet_address));
        storage::init? = true;
        storage::jetton_wallet_address = in_msg_body~load_msg_addr();

        save_data();
        return ();
    }

    ;; allocate jettons (used only once)
    if (op == op::transfer_notification) { 
        int transferred_jettons = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        
        ifnot (in_msg_body.slice_refs_empty?()) {
            slice jetton_payload = in_msg_body~load_ref().begin_parse();
            if (jetton_payload~load_uint(32) == op::liquidity_fulfill) {
                send_jettons(query_id, transferred_jettons, null_addr(), my_address(), sender_address, 0, mode::carry_remaining_gas, 0, null());
                return ();
            }
        }
        
        if (storage::jettons_added? | 
            (transferred_jettons != storage::allocated_jettons) |
            (~ equal_slices(sender_address, storage::jetton_wallet_address))) {
            ;; try to return jettons back
            send_jettons(query_id, transferred_jettons, from_address, from_address, sender_address, 0, mode::carry_remaining_gas,
                             0, begin_cell().store_uint(0, 32).store_slice("Can't add jettons").end_cell());
            return ();
        } 
        
        storage::jettons_added? = true;
        
        send_builder_message(storage::owner_address, query_id, begin_cell().store_uint(op::excesses, 32).store_uint(query_id, 64), mode::carry_remaining_gas);
        save_data();
        return ();
    }

    ;; Admin commands (TODO)
    throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::admin_address));

    if (op == op::change_owner) {
        storage::owner_address = in_msg_body~load_msg_addr();

        send_builder_message(storage::owner_address, 0, begin_cell().store_uint(op::excesses, 32).store_uint(query_id, 64), mode::carry_remaining_gas);
        save_data();
        return ();
    }

    if (op == op::change_purchase_info) {
        ;; TODO allow to increase prices
        throw_unless(exc::already_started, now() < storage::sale_start_time);
        storage::purchase_conditions = in_msg_body~load_ref();

        send_builder_message(storage::owner_address, 0, begin_cell().store_uint(op::excesses, 32).store_uint(query_id, 64), mode::carry_remaining_gas);
        save_data();
        return ();
    }

    if (op == op::add_ref_addresses) {
        ;; TODO allow to add refs with cashback not exceeding current maximum value
        throw_unless(exc::already_started, now() < storage::sale_start_time);
        cell new_addresses = in_msg_body~load_dict();
        (int ref_address, slice ref_conditions, int success) = new_addresses.udict_get_min?(256);
        while (success) {
            storage::refs_dict~udict_set(256, ref_address, ref_conditions);
            (ref_address, ref_conditions, success) = new_addresses.udict_get_next?(256, ref_address);
        }

        send_builder_message(storage::owner_address, 0, begin_cell().store_uint(op::excesses, 32).store_uint(query_id, 64), mode::carry_remaining_gas);
        save_data();
        return (); 
    }


    throw(0xffff);
}


;; Jetton

(int, int, slice, cell, cell) get_jetton_data() method_id {
    load_data();
    return (storage::jettons_sold, storage::jettons_added? & (storage::jettons_sold <= jettons_for_sale) & (now() <= storage::sale_end_time), storage::owner_address, storage::content, storage::sbt_item_code);
}


slice get_wallet_address(slice owner_address) method_id {
    load_data();
    var(_, index) = parse_std_addr(owner_address);
    cell state_init = calculate_nft_item_state_init(index, storage::sbt_item_code, my_address());
    return get_address_by_state_init(state_init);
}


;; ;; SBT
;;
;; (int, cell, slice) get_collection_data() method_id {
;;     load_data();
;;     slice cs = storage::content.begin_parse();
;;     return (uint_256_max, cs~load_ref(), storage::owner_address);
;; }


;; slice get_nft_address_by_index(int index) method_id {
;;     load_data();
;;     cell state_init = calculate_nft_item_state_init(index, storage::sbt_item_code, my_address());
;;     return get_address_by_state_init(state_init);
;; }


;; (int, int, slice) royalty_params() method_id {
;;     return (0, 100, my_address());
;; }

;; cell get_nft_content(int index, cell individual_nft_content) method_id {
;;     load_data();
;;     slice cs = storage::content.begin_parse();
;;     cs~load_ref();
;;     cell common_content_dict = cs~load_dict();
;;     (slice delimiter_sc, int f) = common_content_dict~udict_delete_get?(256, "delimiter"H);
;;     int delimiter = 9;
;;     if (f) {
;;         delimiter = delimiter_sc~load_uint(8);
;;     }

;;     slice individual_nft_content_cs = individual_nft_content.begin_parse();
;;     int number = individual_nft_content_cs~load_coins();
;;     builder string = begin_cell().store_uint(0, 2).store_slice("Current share: ");

;;     int b = 1;
;;     repeat (delimiter) {
;;         b *= 10;
;;     }
;;     (int quot, int reminder) = number.divmod(b);
;;     int res = 0;
;;     do {
;;         (quot, res) = quot.divmod(10);
;;         string = string.store_uint(res + 48, 256);
;;     } until (quot == 0);

;;     string = string.store_slice(".");

;;     b = 0;
;;     do {
;;         (reminder, res) = reminder.divmod(10);
;;         string = string.store_uint(res + 48, 256);
;;         b += 1;
;;     } until ((reminder == 0) | (b == 4));

;;     (slice ticker, f) = common_content_dict~udict_delete_get?(256, "ticker"H);
;;     ifnot (f) {
;;         ticker = " tokens";
;;     }
;;     string = string.store_ref(begin_cell().store_slice(ticker).end_cell());
;;     common_content_dict~udict_set_ref(256, "description"H, string.end_cell());
        
;;     return (begin_cell()
;;                 .store_uint(0, 8)  ;; onchain tag
;;                 .store_dict(common_content_dict)
;;             .end_cell());
;; }


;; (int, slice, slice, cell, cell, cell, cell, cell, int, int, int, int, int, int, int, int, int, int, slice) get_storage_data() method_id {
;;     load_data();
    
;;     return (
;;         storage::init?,

;;         storage::admin_address,      
;;         storage::owner_address,           
;;         storage::content, 
;;         storage::sbt_item_code,
;;         storage::commission_conditions,

;;         storage::purchase_conditions,   
;;         storage::ref_conditions,

;;         storage::sale_start_time,         
;;         storage::sale_end_time,         
;;         storage::allocated_jettons,      
        
;;         storage::ton_collected,          
;;         storage::jettons_sold,           

;;         storage::first_unlock_time,      
;;         storage::first_unlock_size,      
;;         storage::cycle_length,          
;;         storage::cycles_number,         

;;         storage::allocated_jettons,     
;;         storage::jetton_wallet_address
;;     );
;; }