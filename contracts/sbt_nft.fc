#pragma version >=0.4.0;
#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/utils.fc";


;; Default SBT
global int   storage::index;
global int   storage::init?;
global slice storage::collection_address;
global slice storage::owner_address;
global slice storage::authority_address;  ;;
global cell  storage::content;
global int   storage::revoked_at;
;; Custom
global int   storage::purchased_jettons;    ;; total purchased tokens
global int   storage::collected_ton;        ;; total collected ton
global int   storage::claimed_times;        ;; number of unlocks withdrawed
global int   storage::first_unlock_time;    ;; timestamp of the first unlock
global int   storage::first_unlock_size;    ;; size of the first unlock (in percents)
global int   storage::cycle_length;         ;; time between unlocks in seconds
global int   storage::cycles_number;        ;; number of unlocks excluding initial
global cell  storage::ref_data;             ;; data about invitee


() load_data() impure inline {
    slice ds = get_data().begin_parse();

    storage::index              = ds~load_uint(256);
    storage::collection_address = ds~load_msg_addr();
    storage::init?              = false;

    if (ds.slice_bits() > 0) {
        storage::init?             = true;
        storage::owner_address     = begin_cell().store_uint(1024, 11).store_uint(storage::index, 256).end_cell().begin_parse();
        storage::content           = ds~load_ref();
        storage::authority_address = "EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c"a;
        storage::revoked_at        = 0;

        storage::purchased_jettons = ds~load_coins();
        storage::collected_ton     = ds~load_coins();
        storage::claimed_times  = ds~load_uint(16);
        
        storage::first_unlock_time = ds~load_uint(32);
        storage::first_unlock_size = ds~load_uint(32);
        storage::cycle_length      = ds~load_uint(32);
        storage::cycles_number     = ds~load_uint(16);
        
        storage::ref_data          = ds~load_dict();
    }
}


() save_data() impure {
    set_data(
            begin_cell()
                .store_uint(storage::index, 256)
                .store_slice(storage::collection_address)
                .store_ref(storage::content)
                .store_coins(storage::purchased_jettons)
                .store_coins(storage::collected_ton)
                .store_uint(storage::claimed_times, 16)
                .store_uint(storage::first_unlock_time, 32)
                .store_uint(storage::first_unlock_size, 32)
                .store_uint(storage::cycle_length, 32)
                .store_uint(storage::cycles_number, 16)
                .store_dict(storage::ref_data)
            .end_cell()
    );
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; Default SBT start
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);
    if (op == op::update_sbt_data) {
        throw_unless(405, equal_slices(storage::collection_address, sender_address));
        int new_purchased_jettons = in_msg_body~load_coins();
        int new_collected_ton     = in_msg_body~load_coins();
        int max_collected_ton     = in_msg_body~load_coins();
        if (~ storage::init?) {
            storage::purchased_jettons  = new_purchased_jettons;
            storage::collected_ton      = new_collected_ton;
            storage::claimed_times      = 0;
            
            storage::first_unlock_time  = in_msg_body~load_uint(32);
            storage::cycle_length       = in_msg_body~load_uint(32);
            storage::cycles_number      = in_msg_body~load_uint(16);
            storage::ref_data           = in_msg_body~load_dict();
        }
        else {
            storage::collected_ton += new_collected_ton;
            if (storage::collected_ton > max_collected_ton) {
                send_msg(storage::collection_address, 0, op::cancel_purchase, 0, 
                         begin_cell().store_uint(storage::index, 256).store_coins(new_purchased_jettons).store_coins(new_collected_ton), mode::carry_remaining_gas);
            }
            else {
                send_msg(storage::collection_address, 0, op::approve_purchase, 0, 
                         begin_cell().store_uint(storage::index, 256).store_coins(new_collected_ton).store_dict(storage::ref_data), mode::carry_remaining_gas);
                storage::purchased_jettons += new_purchased_jettons;
                save_data();
            }
        }

        return ();
    }

    ;; Default SBT start

    if (flags & 1) { ;; route all prove_ownership bounced messages to owner
        ;; first op was 0xffffffff, because of bounced, now we need to read real one
        op = in_msg_body~load_uint(32);
        if (op == op::ownership_proof) {
            int query_id = in_msg_body~load_uint(64);
            send_msg(storage::owner_address, 0, op::ownership_proof_bounced, query_id, null(), 64);
        }
        return ();
    }

    int query_id = in_msg_body~load_uint(64);

    if (op == op::request_owner) {
        slice dest = in_msg_body~load_msg_addr();
        cell body = in_msg_body~load_ref();
        int with_content = in_msg_body~load_uint(1);

        var msg = begin_cell()
                    .store_uint(storage::index, 256)
                    .store_slice(sender_address)
                    .store_slice(storage::owner_address)
                    .store_ref(body)
                    .store_uint(storage::revoked_at, 64)
                    .store_uint(with_content, 1);

        if (with_content != 0) {
            msg = msg.store_ref(storage::content);
        }

        send_msg(dest, 0, op::owner_info, query_id, msg, 64);
        return ();
    }

    if (op == op::prove_ownership) {
        throw_unless(401, equal_slices(storage::owner_address, sender_address));

        slice dest = in_msg_body~load_msg_addr();
        cell body = in_msg_body~load_ref();
        int with_content = in_msg_body~load_uint(1);

        var msg = begin_cell()
                .store_uint(storage::index, 256)
                .store_slice(storage::owner_address)
                .store_ref(body)
                .store_uint(storage::revoked_at, 64)
                .store_uint(with_content, 1);

        if (with_content != 0) {
            msg = msg.store_ref(storage::content);
        }

        send_msg(dest, 0, op::ownership_proof, query_id, msg, 64);
        return ();
    }

    if (op == op::get_static_data) {
        var msg = begin_cell().store_uint(storage::index, 256).store_slice(storage::collection_address);

        send_msg(sender_address, 0, op::report_static_data, query_id, msg, 64);
        return ();
    }

    if (op == op::revoke) {
        throw_unless(401, equal_slices(storage::authority_address, sender_address));
        throw_unless(403, storage::revoked_at == 0);

        storage::revoked_at = now();
        save_data();
        return ();
    }

    if (op == op::take_excess) {
        throw_unless(401, equal_slices(storage::owner_address, sender_address));

        ;; reserve amount for storage
        raw_reserve(min_tons_for_storage, 0);

        send_msg(sender_address, 0, op::excesses, query_id, null(), 128);
        return ();
    }

    if (op == op::transfer) {
        throw(413);
    }
    ;; default SBT end

    int now_time = now();
    
    if (op == op::claim) {
        throw_unless(exc::incorrect_sender, equal_slices(storage::owner_address, sender_address));

        if (now_time > storage::first_unlock_time) {
            int total_unlocks = 1 + min(storage::cycles_number, (now_time - storage::first_unlock_time) / storage::cycle_length);
            int available_percent = muldiv((total_unlocks - storage::claimed_times), percent_devider, storage::cycles_number);
            if (storage::claimed_times == 0) {
                available_percent += storage::first_unlock_size;
            }
            throw_unless(exc::nothing_to_claim, available_percent);
            int available_jettons = muldiv(storage::purchased_jettons, available_percent, percent_devider);
            send_msg(storage::collection_address, gas::claim_jettons, op::claim, query_id, 
                     begin_cell().store_uint(storage::index, 256).store_coins(available_jettons), mode::carry_remaining_gas);

            storage::claimed_times = total_unlocks; 
            save_data();
            return ();
        }
        else {
            throw(exc::not_unlocked_yet);
        }
    }

    if (op == op::destroy) {
        throw_unless(exc::incorrect_sender, equal_slices(storage::owner_address, sender_address));
        throw_unless(exc::not_claimed_yet, storage::claimed_times == storage::cycles_number + 1);  ;; can burn SBT only after all claims

        send_msg(sender_address, 0, op::excesses, query_id, null(), 128);
        storage::owner_address = null_addr();
        storage::authority_address = null_addr();

        save_data();
        return ();
    }

    throw(0xffff);
}


;;
;;  GET Methods
;;

(int, int, slice, slice, cell) get_nft_data() method_id {
    load_data();
    return (storage::init?, storage::index, storage::collection_address, storage::owner_address, storage::content);
}

slice get_authority_address() method_id {
    load_data();
    return storage::authority_address;
}

int get_revoked_time() method_id {
    load_data();
    return storage::revoked_at;
}


(int, slice, int, int, int, int, int, int, int, cell) get_storage_data() method_id {
    load_data();

    return (
        storage::index,
        storage::owner_address,
        storage::purchased_jettons,
        storage::collected_ton,
        storage::claimed_times,
        storage::first_unlock_time,
        storage::first_unlock_size,
        storage::cycle_length,
        storage::cycles_number,
        storage::ref_data
    );      
}
