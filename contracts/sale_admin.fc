#pragma version >=0.4.0;
#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/utils.fc";


global slice storage::owner_address;           ;; Admin of this smart-contract (MsgAddress)       
global slice storage::jetton_wallet_address;   ;; Address of wallet of the jetton used for fees. (MsgAddress)
global cell  storage::revenue_share_addresses; ;; Hashmap. Key = index (uint8), value = Slice(address (MsgAddress), share (uint32))

global cell  storage::creation_fees;           ;; Hashmap. Key = maximum collected TON (uint128), value = fee required to create new sale (Coins)
global cell  storage::commission_factors;      ;; Hashmap. Key = minimum collected TON (uint128), Value = commission_factor (uint32)

global cell  storage::ico_sale_code;           ;; Code of the ico (ico_sale.fc) smart-contract. (Cell)
global cell  storage::sbt_item_code;           ;; Code of the ico bond SBT item (sbt_item.fc) smart-contract. (Cell)
global cell  storage::ref_wallet_code;         ;; Code of the ref wallet (ref_wallet.fc) smart-contract (Cell)


() load_data() impure inline {
    slice ds = get_data().begin_parse();

    storage::owner_address           = ds~load_msg_addr();
    storage::jetton_wallet_address   = ds~load_msg_addr();
    storage::revenue_share_addresses = ds~load_ref();

    storage::creation_fees           = ds~load_ref();
    storage::commission_factors      = ds~load_ref();

    slice codes = ds~load_ref().begin_parse();
    storage::ico_sale_code   = codes~load_ref();
    storage::sbt_item_code   = codes~load_ref();
    storage::ref_wallet_code = codes~load_ref();
}   


() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::owner_address)
            .store_slice(storage::jetton_wallet_address)
            .store_ref(storage::revenue_share_addresses)
            .store_ref(storage::creation_fees)
            .store_ref(storage::commission_factors)
            .store_ref(
                begin_cell()
                    .store_ref(storage::ico_sale_code)
                    .store_ref(storage::sbt_item_code)
                    .store_ref(storage::ref_wallet_code)
                .end_cell()
            )
        .end_cell()
    );
}


cell get_sale_data(slice sender_address, slice sale_data, int transferred_jettons) impure inline { ;; returns new ico_cale c4 data
    ;; load sale data
    int   init?                 = 0;
    int   sale_start_time       = sale_data~load_uint(32);
    int   sale_end_time         = sale_data~load_uint(32);

    int   min_ton_collected     = sale_data~load_coins();
    int   allocated_jettons     = sale_data~load_coins();
    int   liquidity_part_ton    = sale_data~load_uint(32);
    int   liquidity_part_jetton = sale_data~load_uint(32);

    int   ton_collected         = 0;
    int   jettons_sold          = 0;

    int   first_unlock_time     = sale_data~load_uint(32);
    int   first_unlock_size     = sale_data~load_uint(16);
    int   cycle_length          = sale_data~load_uint(32);
    int   cycles_number         = sale_data~load_uint(16);

    slice jetton_wallet_address = sale_data~load_msg_addr();
    int   jettons_added?        = 0;
    int   sale_finished?        = 0;

    slice admin_address         = my_address();
    slice owner_address         = sender_address;
    cell  content               = sale_data~load_ref();
    cell  sbt_item_code         = sale_data~load_ref();

    slice internal_sale_data    = sale_data~load_ref().begin_parse();
    slice jetton_root_address   = internal_sale_data~load_msg_addr();
    slice native_vault_address  = internal_sale_data~load_msg_addr();
    slice jetton_vault_address  = internal_sale_data~load_msg_addr();
    cell  purchase_conditions   = internal_sale_data~load_ref();
    cell  commission_factors    = storage::commission_factors;
    
    slice ref_conditions        = sale_data~load_ref().begin_parse();
    int   min_ref_purchase      = ref_conditions~load_coins();
    int   default_cashback      = ref_conditions~load_uint(32);
    cell  refs_dict             = ref_conditions~load_dict();
    cell  ref_wallet_code       = ref_conditions~load_ref(); 

    ;; check some integer values
    throw_unless(exc::int_out_of_range, (default_cashback > 0) & (sale_start_time > 0) & (sale_end_time > sale_start_time) &
                                        (liquidity_part_jetton >= 0) & (liquidity_part_ton >= 0) & (first_unlock_time >= sale_end_time) &
                                        (first_unlock_size >= 0) & (cycle_length >= 0) & (cycles_number >= 0));

    ;; check purchase conditions
    slice purchase_conditions_parsed = purchase_conditions.begin_parse();
    int price_factor     = purchase_conditions_parsed~load_uint(128);
    int price_devider    = purchase_conditions_parsed~load_uint(128);
    int min_purchase_ton = purchase_conditions_parsed~load_coins();
    int max_purchase_ton = purchase_conditions_parsed~load_coins();
    throw_unless(exc::int_out_of_range, (price_factor > 0) & (price_devider > 0) & (min_purchase_ton > 0) & (max_purchase_ton > min_purchase_ton));

    ;; check that payed fee is correct
    int max_ton_collected = muldiv(muldiv(allocated_jettons, percent_devider - liquidity_part_jetton, percent_devider), price_devider, price_factor);
    (_, slice fee_slice, int success) = storage::creation_fees.udict_get_nexteq?(128, max_ton_collected);
    throw_unless(exc::not_enough_jettons, fee_slice~load_coins() != transferred_jettons);

    ;; check whitelist conditions
    repeat(slice_refs(purchase_conditions_parsed)) {
        slice tmp = purchase_conditions_parsed~load_ref().begin_parse();
        price_factor     = tmp~load_uint(128);
        price_devider    = tmp~load_uint(128);
        min_purchase_ton = tmp~load_coins();
        max_purchase_ton = tmp~load_coins();
        throw_unless(exc::int_out_of_range, (price_factor > 0) & (price_devider > 0) & (min_purchase_ton > 0) & (max_purchase_ton > min_purchase_ton));
    }
    
    ;; return full c4 of ico_sale smart contract
    return begin_cell()
                .store_int(init?, 1)

                .store_uint(sale_start_time, 32)
                .store_uint(sale_end_time, 32)
                
                .store_coins(min_ton_collected)
                .store_coins(allocated_jettons)
                .store_uint(liquidity_part_ton, 32)
                .store_uint(liquidity_part_jetton, 32)

                .store_coins(ton_collected)
                .store_coins(jettons_sold)

                .store_uint(first_unlock_time, 32)
                .store_uint(first_unlock_size, 16)
                .store_uint(cycle_length, 32)
                .store_uint(cycles_number, 16)
                
                .store_slice(jetton_wallet_address)
                .store_int(jettons_added?, 1)
                .store_int(sale_finished?, 1)

                .store_ref( ;; collection_info
                    begin_cell()
                        .store_slice(admin_address)
                        .store_slice(owner_address)
                        .store_ref(content)
                        .store_ref(sbt_item_code)
                    .end_cell()
                ) ;; \collection_info
                .store_ref( ;; internal_ds
                    begin_cell()
                        .store_slice(jetton_root_address)
                        .store_slice(native_vault_address)
                        .store_slice(jetton_vault_address)
                        .store_ref(purchase_conditions)
                        .store_ref(commission_factors)
                        .store_coins(min_ref_purchase)
                        .store_uint(default_cashback, 32)
                        .store_dict(refs_dict)
                        .store_ref(ref_wallet_code)
                    .end_cell()
                ) ;; \internal_ds
            .end_cell();
}


slice deploy_ico_sale(cell sale_data) impure inline {  ;; deploys new staking pool contract and returns its address

    cell sale_state_init = begin_cell()
                                .store_uint(0, 2)
                                .store_dict(storage::ico_sale_code)
                                .store_dict(sale_data)
                                .store_uint(0, 1)
                            .end_cell();

    slice sale_address = begin_cell()
                            .store_uint(1024, 11)
                            .store_uint(cell_hash(sale_state_init), 256)
                        .end_cell().begin_parse();

    send_deploy_message(sale_address, gas::deploy_ico_sale, sale_state_init, null(), mode::simple);

    return sale_address;
}


() send_commissions(slice jetton_wallet_address, int coins_amount, int query_id, int is_jetton) impure inline {
    (int index, slice share_data, int success) = storage::revenue_share_addresses.udict_get_min?(8);
    while (success) {
        slice to_address = share_data~load_msg_addr();
        int address_share = share_data~load_uint(32);
        int address_coins = muldiv(coins_amount, address_share, percent_devider);
        if (is_jetton) {
            send_jettons(query_id, address_coins, to_address, to_address, jetton_wallet_address, gas::send_jettons, mode::simple,
                        0, begin_cell().store_uint(0, 32).store_slice("JVault launchpad revenue share").end_cell());
        }
        else {
            send_message_with_comment(to_address, address_coins, "JVault launchpad revenue share", mode::simple);
        }
        (index, share_data, success) = storage::revenue_share_addresses.udict_get_next?(8, index);
    }
    return ();
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    load_data();

    if (op == op::transfer_notification) {  ;; someone sent jettons to this smc
        int   jetton_amount = in_msg_body~load_coins();
        slice from_address  = in_msg_body~load_msg_addr();
        try {
            raw_reserve(0, 4);

            slice payload = in_msg_body~load_uint(1) ? in_msg_body~load_ref().begin_parse() : in_msg_body;
            int inner_op = payload~load_uint(32);
            
            if (inner_op == op::deploy_ico_sale) {
                throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::jetton_wallet_address));

                cell sale_data = get_sale_data(sender_address, payload, jetton_amount);
                deploy_ico_sale(sale_data);

                send_commissions(storage::jetton_wallet_address, jetton_amount, query_id, true);
                return ();
            }
            
            if (inner_op == op::send_commissions) {
                send_commissions(sender_address, jetton_amount, query_id, true);
                return ();
            }

            throw(exc::unsupported_op);
        }
        catch (_, _) {
            send_jettons(query_id, jetton_amount, from_address, from_address, sender_address, 0, mode::carry_remaining_gas,
                         1, begin_cell().store_uint(0, 32).store_slice("Incorrect payload").end_cell());  
            return ();
        }
    }

    if (op == op::excesses) { 
        return();
    } 

    if (op == op::send_commissions) {
        send_commissions(null(), msg_value, query_id, false);
        return ();
    }
    
    throw_unless(exc::incorrect_sender, equal_slices(sender_address, storage::owner_address));

    if (op == op::withdraw_ton) {
        send_commissions(null(), my_balance - min_tons_for_storage, query_id, false);
        return ();
    }

    if (op == op::change_owner) {
        storage::owner_address = in_msg_body~load_msg_addr();
        send_message_with_comment(storage::owner_address, 0, "Sale admin owner_address was changed", mode::carry_remaining_gas);
        save_data();
        return ();
    }

    if (op == op::change_jetton_wallet) {
        storage::jetton_wallet_address = in_msg_body~load_msg_addr();
        send_message_with_comment(storage::owner_address, 0, "Sale admin jetton_wallet_address was changed", mode::carry_remaining_gas);
         save_data();
        return ();
    }

    if (op == op::change_revenue_share) {
        storage::revenue_share_addresses = in_msg_body~load_ref();
        send_message_with_comment(storage::owner_address, 0, "Sale admin revenue_share_addresses was changed", mode::carry_remaining_gas);
        save_data();
        return ();
    }

    if (op == op::change_creation_fees) {
        storage::creation_fees = in_msg_body~load_ref();
        send_message_with_comment(storage::owner_address, 0, "Sale admin creation_fees was changed", mode::carry_remaining_gas);
        save_data();
        return ();
    }

    if (op == op::change_commissions) {
        storage::commission_factors = in_msg_body~load_ref();
        send_message_with_comment(storage::owner_address, 0, "Sale admin сommission_factors was changed", mode::carry_remaining_gas);
        save_data();
        return ();
    }

    if (op == op::change_codes) {
        storage::ico_sale_code = in_msg_body~load_ref();
        storage::sbt_item_code = in_msg_body~load_ref();
        storage::ref_wallet_code = in_msg_body~load_ref();
        send_message_with_comment(storage::owner_address, 0, "Sale admin codes were changed", mode::carry_remaining_gas);
        save_data();
        return ();
    }
    ;; if (op == op::send_any_message) {
    ;;     send_raw_message(in_msg_body~load_ref(), 64);
    ;;     return ();
    ;; }

    ;; if (op == 0xfffe) {  ;; set data
    ;;     set_data(in_msg_body~load_ref());
    ;;     send_message_with_comment(storage::owner_address, 0, "Sale admin data was changed", mode::carry_remaining_gas);
    ;;     return ();
    ;; }
    ;; if (op == 0xffff) {  ;; set code
    ;;     send_message_with_comment(storage::owner_address, 0, "Sale admin code was changed", mode::carry_remaining_gas);
    ;;     set_code(in_msg_body~load_ref());
    ;;     return ();
    ;; }

    throw(exc::unsupported_op);
}


;; GET methods

